// lib/src/services/hydration_service.dart
import 'dart:math' as math; // For math.max and math.min
import 'package:minum/src/data/models/hydration_entry_model.dart';
import 'package:minum/src/data/models/user_model.dart';
import 'package:minum/src/data/repositories/hydration_repository.dart';
import 'package:minum/src/services/health_service.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:health/health.dart';
import 'package:minum/main.dart'; // For logger

/// A service layer for managing hydration data and business logic.
///
/// This class uses a [HydrationRepository] to interact with the data layer
/// and provides methods for adding, updating, deleting, and retrieving
/// hydration entries, as well as calculating recommended intake.
class HydrationService {
  final HydrationRepository _hydrationRepository;
  final HealthService _healthService;

  /// Creates a `HydrationService` instance.
  ///
  /// Requires a [hydrationRepository] and [healthService].
  HydrationService({
    required HydrationRepository hydrationRepository,
    required HealthService healthService,
  })  : _hydrationRepository = hydrationRepository,
        _healthService = healthService;

  /// Adds a new hydration entry.
  Future<void> addHydrationEntry({
    required String userId,
    required double amountMl,
    required DateTime timestamp,
    String? notes,
    String? source,
    String? healthConnectId,
  }) async {
    try {
      final entry = HydrationEntry(
        userId: userId,
        amountMl: amountMl,
        timestamp: timestamp,
        notes: notes,
        source: source ?? 'manual',
        healthConnectId: healthConnectId,
      );
      await _hydrationRepository.addHydrationEntry(userId, entry);
      logger.i(
          "HydrationService: Entry added for user $userId, amount ${amountMl}ml.");

      // Sync to Health Connect if enabled and not already from Health Connect
      if (source != 'health_connect') {
        final prefs = await SharedPreferences.getInstance();
        final bool healthConnectEnabled =
            prefs.getBool('prefs_health_connect_enabled') ?? false;

        if (healthConnectEnabled) {
          // Use the entry's ID (or a generated one if needed) as clientRecordId
          // Since we just added it, we might need to rely on the repository to return the ID,
          // but HydrationEntry is created here.
          // However, Firestore ID is generated by the repository if not provided.
          // For local DB, ID is auto-increment.
          // To ensure consistency, we should ideally use a UUID generated here if not present.
          // But for now, let's use the ID if available, or maybe we should generate a UUID for the entry here?
          // Actually, HydrationEntry doesn't enforce UUID.
          // Let's use the timestamp as a seed for a unique ID if we don't have one, or just let Health Connect handle it if we can't provide a stable one.
          // BUT, to prevent duplicates, we really want a stable ID.
          // The best way is to generate a UUID for the entry *before* saving it.
          // But HydrationEntry.id is String? and usually Firestore ID.
          // Let's assume we can use a combination of userId and timestamp for now, or just pass null if we can't guarantee stability.
          // Wait, if we use `entry.id`, it might be null at this point because it's assigned by Firestore/SQLite.
          // So we should probably generate a UUID for `healthConnectId` (which we added!) and use THAT as `clientRecordId`?
          // No, `healthConnectId` is for the ID *from* Health Connect.
          // We need an ID *for* Health Connect.
          // Let's generate a UUID here and store it?
          // Or just use `userId_timestamp`?
          final String uniqueId =
              '${userId}_${timestamp.millisecondsSinceEpoch}';
          await _healthService.writeHydrationData(amountMl, timestamp,
              clientRecordId: uniqueId);
        }
      }
    } catch (e) {
      logger
          .e("HydrationService: Error adding hydration entry for $userId: $e");
      throw Exception("Failed to log water intake.");
    }
  }

  /// Updates an existing hydration entry.
  Future<void> updateHydrationEntry(String userId, HydrationEntry entry) async {
    try {
      await _hydrationRepository.updateHydrationEntry(userId, entry);
      logger.i(
          "HydrationService: Entry ${entry.id ?? entry.localDbId} updated for user $userId.");
    } catch (e) {
      logger.e(
          "HydrationService: Error updating entry ${entry.id ?? entry.localDbId} for $userId: $e");
      throw Exception("Failed to update water intake log.");
    }
  }

  /// Deletes a hydration entry.
  Future<void> deleteHydrationEntry(
      String userId, HydrationEntry entryToDelete) async {
    try {
      await _hydrationRepository.deleteHydrationEntry(userId, entryToDelete);
      logger.i(
          "HydrationService: Entry ${entryToDelete.id ?? entryToDelete.localDbId} delete initiated for user $userId.");

      // Delete from Health Connect if it has a Health Connect ID or if we want to try deleting by time
      // Since we can't delete by ID reliably with the current package version, we delete by time range.
      // We use the same 1-minute window used during writing.
      if (entryToDelete.healthConnectId != null ||
          entryToDelete.source == 'manual') {
        logger.i(
            "HydrationService: Deleting entry from Health Connect by time range: ${entryToDelete.timestamp}");
        await _healthService.deleteHydrationData(
          entryToDelete.timestamp,
          entryToDelete.timestamp.add(const Duration(minutes: 1)),
        );
      }
    } catch (e) {
      logger.e(
          "HydrationService: Error deleting entry ${entryToDelete.id ?? entryToDelete.localDbId} for $userId: $e");
      throw Exception("Failed to delete water intake log.");
    }
  }

  /// Retrieves a stream of hydration entries for a specific day.
  ///
  /// @return A stream of lists of `HydrationEntry` objects.
  Stream<List<HydrationEntry>> getHydrationEntriesForDay(
      String userId, DateTime date) {
    try {
      return _hydrationRepository.getHydrationEntriesForDay(userId, date);
    } catch (e) {
      logger.e(
          "HydrationService: Error fetching entries for day for $userId: $e");
      return Stream.value([]);
    }
  }

  /// Retrieves a stream of hydration entries for a date range.
  ///
  /// @return A stream of lists of `HydrationEntry` objects.
  Stream<List<HydrationEntry>> getHydrationEntriesForDateRange(
      String userId, DateTime startDate, DateTime endDate) {
    try {
      return _hydrationRepository.getHydrationEntriesForDateRange(
          userId, startDate, endDate);
    } catch (e) {
      logger.e(
          "HydrationService: Error fetching entries for date range for $userId: $e");
      return Stream.value([]);
    }
  }

  /// Calculates the total intake from a list of hydration entries.
  ///
  /// @return The total volume in milliliters.
  double calculateTotalIntake(List<HydrationEntry> entries) {
    if (entries.isEmpty) return 0.0;
    return entries.fold(0.0, (sum, entry) => sum + entry.amountMl);
  }

  /// Calculates the recommended daily water intake for a user based on their profile.
  ///
  /// The calculation considers weight, gender, age, activity level, health
  /// conditions, and weather.
  /// @return A `Future` that completes with the recommended intake in milliliters.
  Future<double> calculateRecommendedDailyIntake({
    required UserModel user,
  }) async {
    logger.i(
        "Calculating recommended intake for user: ${user.id}, Weight: ${user.weightKg}kg, Gender: ${user.gender}, Age: ${user.age}, Activity: ${user.activityLevel}, Weather: ${user.selectedWeatherCondition}, Health: ${user.healthConditions}");

    // 1. Base Calculation
    double baseIntakeWeight = 2000.0;
    if (user.weightKg != null && user.weightKg! > 0) {
      baseIntakeWeight = user.weightKg! * 33.0;
    }

    double baseIntakeGender = 2000.0;
    if (user.gender == Gender.male) {
      baseIntakeGender = 2500.0;
    } else if (user.gender == Gender.female) {
      baseIntakeGender = 2000.0;
    }

    double finalBaseIntake = math.max(baseIntakeWeight, baseIntakeGender);
    logger.d(
        "Base (Weight): ${baseIntakeWeight.toInt()}mL, Base (Gender): ${baseIntakeGender.toInt()}mL, Final Base: ${finalBaseIntake.toInt()}mL");

    double calculatedTotalNeed = finalBaseIntake;

    // 2. Age Adjustment
    if (user.age != null) {
      if (user.age! < 30) {
        calculatedTotalNeed *= 1.05;
        logger.d("Age < 30 adjustment (+5%): ${calculatedTotalNeed.toInt()}mL");
      } else if (user.age! > 65) {
        calculatedTotalNeed *= 1.10;
        logger
            .d("Age > 65 adjustment (+10%): ${calculatedTotalNeed.toInt()}mL");
      }
    }

    // 3. Activity Level Adjustment
    double activityAdditiveMl = 0;
    switch (user.activityLevel) {
      case ActivityLevel.sedentary:
        activityAdditiveMl = 0;
        break;
      case ActivityLevel.light:
        activityAdditiveMl = 350;
        break;
      case ActivityLevel.moderate:
        activityAdditiveMl = 700;
        break;
      case ActivityLevel.active:
        activityAdditiveMl = 1050;
        break;
      case ActivityLevel.extraActive:
        activityAdditiveMl = 1400;
        break;
      case null:
        activityAdditiveMl = 0;
        logger.d("Activity level not set, no additive adjustment.");
        break;
    }
    calculatedTotalNeed += activityAdditiveMl;
    logger.d(
        "Activity adjustment: Additive ${activityAdditiveMl.toInt()}mL. Intake after activity: ${calculatedTotalNeed.toInt()}mL");

    // 4. Health Conditions Adjustment
    if (user.healthConditions != null &&
        user.healthConditions!.isNotEmpty &&
        !user.healthConditions!.contains(HealthCondition.none)) {
      for (var condition in user.healthConditions!) {
        switch (condition) {
          case HealthCondition.pregnancy:
            calculatedTotalNeed *= 1.30;
            logger.d(
                "Health (Pregnancy) adjustment (+30%): ${calculatedTotalNeed.toInt()}mL");
            break;
          case HealthCondition.breastfeeding:
            calculatedTotalNeed *= 1.50;
            logger.d(
                "Health (Breastfeeding) adjustment (+50%): ${calculatedTotalNeed.toInt()}mL");
            break;
          case HealthCondition.kidneyIssues:
            calculatedTotalNeed *= 0.90;
            logger.d(
                "Health (Kidney) adjustment (-10%): ${calculatedTotalNeed.toInt()}mL - Advise Doctor Consultation");
            break;
          case HealthCondition.heartConditions:
            calculatedTotalNeed *= 0.95;
            logger.d(
                "Health (Heart) adjustment (-5%): ${calculatedTotalNeed.toInt()}mL - Advise Doctor Consultation");
            break;
          case HealthCondition.none:
            break;
        }
      }
    }

    // 5. Weather Adjustment
    if (user.selectedWeatherCondition != null) {
      switch (user.selectedWeatherCondition!) {
        case WeatherCondition.hot:
          calculatedTotalNeed *= 1.30;
          logger.d(
              "Weather (Hot) adjustment (+30%): ${calculatedTotalNeed.toInt()}mL");
          break;
        case WeatherCondition.hotAndHumid:
          calculatedTotalNeed *= 1.40;
          logger.d(
              "Weather (Hot & Humid) adjustment (+40%): ${calculatedTotalNeed.toInt()}mL");
          break;
        case WeatherCondition.cold:
          calculatedTotalNeed *= 0.95;
          logger.d(
              "Weather (Cold) adjustment (-5%): ${calculatedTotalNeed.toInt()}mL");
          break;
        case WeatherCondition.temperate:
          logger.d("Weather (Temperate) adjustment: None");
          break;
      }
    }

    // 6. Final Goal from Beverages (80% of total physiological need)
    double finalGoalFromBeverages = calculatedTotalNeed * 0.80;
    logger.d(
        "Total physiological water need (100%): ${calculatedTotalNeed.toInt()}mL. Target from beverages (80%): ${finalGoalFromBeverages.toInt()}mL");

    finalGoalFromBeverages = finalGoalFromBeverages.clamp(1000.0, 10000.0);
    finalGoalFromBeverages = (finalGoalFromBeverages / 50).round() * 50.0;

    logger.i(
        "HydrationService: Final Calculated Recommended Intake (from beverages) for user ${user.id}: ${finalGoalFromBeverages.toInt()}mL");

    return finalGoalFromBeverages;
  }

  bool _isSyncing = false;

  /// Syncs hydration data from Health Connect.
  Future<void> syncHealthConnectData(String userId, {DateTime? date}) async {
    if (_isSyncing) {
      logger.d("HydrationService: Sync already in progress. Skipping.");
      return;
    }
    _isSyncing = true;

    try {
      final prefs = await SharedPreferences.getInstance();
      final bool healthConnectEnabled =
          prefs.getBool('prefs_health_connect_enabled') ?? false;

      if (!healthConnectEnabled) {
        logger.d("HydrationService: Health Connect sync disabled.");
        return;
      }

      final targetDate = date ?? DateTime.now();
      final startTime =
          DateTime(targetDate.year, targetDate.month, targetDate.day, 0, 0, 0);
      final endTime = DateTime(
          targetDate.year, targetDate.month, targetDate.day, 23, 59, 59);

      // Fetch from Health Connect
      final healthData =
          await _healthService.readHydrationData(startTime, endTime);

      if (healthData.isEmpty) {
        logger.d(
            "HydrationService: No data found in Health Connect for $targetDate.");
        return;
      }

      // Fetch local data to avoid duplicates
      final localEntriesStream =
          _hydrationRepository.getHydrationEntriesForDay(userId, targetDate);
      final localEntries = await localEntriesStream.first;

      // Create a mutable list of local entries to track which ones have been matched
      final availableLocalEntries = List<HydrationEntry>.from(localEntries);

      int syncedCount = 0;
      for (var point in healthData) {
        double amountMl = 0.0;
        if (point.value is NumericHealthValue) {
          amountMl =
              (point.value as NumericHealthValue).numericValue.toDouble() *
                  1000;
        } else {
          continue;
        }

        logger.d(
            "HydrationService: Processing Health Connect point. UUID: ${point.uuid}, Amount: ${amountMl}ml, Date: ${point.dateFrom}");

        HydrationEntry? matchedLocalEntry;

        // 1. Check for duplicate using Health Connect ID (uuid)
        // We look in availableLocalEntries to ensure we haven't matched this one yet
        try {
          matchedLocalEntry = availableLocalEntries.firstWhere((local) {
            return local.healthConnectId == point.uuid;
          });
        } catch (e) {
          // Not found
        }

        // 2. Fallback: Check by timestamp and amount if ID is missing or not matched
        if (matchedLocalEntry == null) {
          try {
            matchedLocalEntry = availableLocalEntries.firstWhere((local) {
              final timeDiff =
                  local.timestamp.difference(point.dateFrom).inSeconds.abs();
              // Only match if it doesn't already have a DIFFERENT Health Connect ID
              // If it has NO Health Connect ID, it's a candidate.
              // If it has a Health Connect ID, it should have matched by UUID above.
              // Exception: If the local entry has a HC ID but it doesn't match this point's UUID,
              // it's a different entry (e.g. user manually added one, then synced another).
              // So we strictly prefer entries with NO HC ID for fuzzy matching.
              if (local.healthConnectId != null) return false;

              return (local.amountMl - amountMl).abs() < 1.0 && timeDiff < 5;
            });
          } catch (e) {
            // Not found
          }
        }

        if (matchedLocalEntry != null) {
          logger.d(
              "HydrationService: Duplicate found (UUID: ${point.uuid} matches local ID: ${matchedLocalEntry.id ?? matchedLocalEntry.localDbId})");

          // Remove from available pool so it can't be matched again
          availableLocalEntries.remove(matchedLocalEntry);

          // If we found a duplicate by content but it doesn't have the healthConnectId, update it.
          if (matchedLocalEntry.healthConnectId == null) {
            logger.i(
                "HydrationService: Linking local entry to Health Connect ID ${point.uuid}");
            final updatedEntry =
                matchedLocalEntry.copyWith(healthConnectId: point.uuid);
            await updateHydrationEntry(userId, updatedEntry);
          }
        } else {
          // No match found in available entries -> It's new!
          logger.i(
              "HydrationService: New entry found from Health Connect: ${point.uuid}");
          await addHydrationEntry(
            userId: userId,
            amountMl: amountMl,
            timestamp: point.dateFrom,
            source: 'health_connect',
            notes: 'Synced from Health Connect',
            healthConnectId: point.uuid,
          );
          syncedCount++;
        }
      }

      if (syncedCount > 0) {
        logger.i(
            "HydrationService: Synced $syncedCount entries from Health Connect for $targetDate.");
      } else {
        logger.d(
            "HydrationService: All Health Connect entries already exist locally for $targetDate.");
      }
    } catch (e) {
      logger.e("HydrationService: Error syncing Health Connect data: $e");
    } finally {
      _isSyncing = false;
    }
  }
}
